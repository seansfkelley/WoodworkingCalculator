// This file is automatically generated by Citron version 2.0.
//
// The parser class defined below conforms to the CitronParser protocol
// defined in CitronParser.swift. 
// 
// The authors of Citron disclaim copyright to the source code in this file.

// Parser class

class WoodworkingCalculatorParser: CitronParser {

    // Types

    typealias CitronSymbolNumber = UInt8
    typealias CitronStateNumber = UInt8
    typealias CitronRuleNumber = UInt8

    enum CitronTokenCode: CitronSymbolNumber {
      case Add                            =   1
      case Subtract                       =   2
      case Multiply                       =   3
      case Divide                         =   4
      case LeftParen                      =   5
      case RightParen                     =   6
      case Feet                           =   7
      case Inches                         =   8
      case Integer                        =   9
      case Fraction                       =  10
    }

    enum CitronNonTerminalCode: CitronSymbolNumber {
      case equation                       =  11
      case expression                     =  12
      case multiplicative                 =  13
      case atom                           =  14
      case quantity                       =  15
      case integer                        =  16
      case fraction                       =  17
    }

    enum CitronSymbolCode : RawRepresentable, Equatable {
        case token(CitronTokenCode)
        case nonterminal(CitronNonTerminalCode)
        case endOfInput

        init(_ token: CitronTokenCode) { self = .token(token) }
        init(_ nonterminal: CitronNonTerminalCode) { self = .nonterminal(nonterminal) }
        init(rawValue: CitronSymbolNumber) {
            if (rawValue == 0) {
                self = .endOfInput
            } else if (rawValue < 11) {
                self = .token(CitronTokenCode(rawValue: rawValue)!)
            } else if (rawValue < 18) {
                self = .nonterminal(CitronNonTerminalCode(rawValue: rawValue)!)
            } else {
                fatalError()
            }
        }

        typealias RawValue = CitronSymbolNumber
        var rawValue: CitronSymbolNumber {
            switch (self) {
            case .token(let t): return t.rawValue
            case .nonterminal(let nt): return nt.rawValue
            case .endOfInput: return 0
            }
        }
    }

    typealias CitronToken = Token

    enum CitronSymbol {
        case yyBaseOfStack
        case yy0(CitronToken)
        case yy8(Int)
        case yy19(Evaluatable)
        case yy27(Fraction)

        func typeErasedContent() -> Any {
            switch (self) {
            case .yyBaseOfStack: fatalError()
            case .yy0(let value): return value as Any
            case .yy8(let value): return value as Any
            case .yy19(let value): return value as Any
            case .yy27(let value): return value as Any
            }
        }
    }

    typealias CitronResult = Evaluatable

    // Counts

    let yyNumberOfSymbols: Int = 18
    let yyNumberOfStates: Int = 17

    // Action tables

    let yyLookaheadAction: [(CitronSymbolNumber, CitronParsingAction)] = [
/*   0 */  (11, .ACCEPT),   (12, .SH(16)), (13, .SH(10)), (14, .SH( 9)), (15, .RD( 7)),
/*   5 */  (16, .SH( 7)), (17, .SH(11)), (12, .RD( 2)), (13, .SH(10)), (14, .SH( 9)),
/*  10 */  (15, .RD( 7)), (16, .SH( 7)), (17, .SH(11)), (12, .SH(15)), (13, .SH(10)),
/*  15 */  (14, .SH( 9)), (15, .RD( 7)), (16, .SH( 7)), (17, .SH(11)), (12, .RD( 1)),
/*  20 */  (13, .SH(10)), (14, .SH( 9)), (15, .RD( 7)), (16, .SH( 7)), (17, .SH(11)),
/*  25 */  (14, .RD( 5)), (15, .RD( 7)), (16, .SH( 7)), (17, .SH(11)), (14, .RD( 4)),
/*  30 */  (15, .RD( 7)), (16, .SH( 7)), (17, .SH(11)), ( 5, .SH( 2)), ( 9, .SR(16)),
/*  35 */  (10, .SR(17)), (17, .SH(12)), ( 9, .SR(16)), (10, .SR(17)), (16, .SH( 8)),
/*  40 */  (17, .SH(13)), ( 7, .SH( 6)), ( 3, .SH( 5)), ( 4, .SH( 4)), (10, .SR(17)),
/*  45 */  ( 1, .SH( 3)), ( 2, .SH( 1)), (10, .SR(17)), (17, .SH(14)), ( 8, .SR(14)),
/*  50 */  ( 8, .SR(12)), ( 8, .SR(10)), ( 6, .SR( 8)), ( 8, .SR( 9)), ( 0, .RD( 0)),
    ]

    let yyShiftUseDefault: Int = 55
    let yyShiftOffsetMin: Int = 0
    let yyShiftOffsetMax: Int = 54
    let yyShiftOffset: [Int] = [
        /*     0 */    28,   28,   28,   28,   28,   28,   25,   34,   37,   39,
        /*    10 */    44,   41,   42,   43,   45,   46,   54,
    ]

    let yyReduceUseDefault: Int = -12
    let yyReduceOffsetMin: Int =   -11
    let yyReduceOffsetMax: Int =   31
    let yyReduceOffset: [Int] = [
        /*     0 */   -11,   -5,    1,    7,   11,   15,   23,   19,   31,
    ]

    let yyDefaultAction: [CitronParsingAction] = [
  /*     0 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*     5 */  .ERROR , .RD(11), .RD(13), .ERROR , .RD( 6),
  /*    10 */  .RD( 3), .RD(15), .ERROR , .ERROR , .ERROR ,
  /*    15 */  .ERROR , .ERROR ,
    ]

    // Fallback

    let yyHasFallback: Bool = false
    let yyFallback: [CitronSymbolNumber] = []

    // Wildcard

    let yyWildcard: CitronSymbolNumber? = nil

    // Rules

    let yyRuleInfo: [(lhs: CitronSymbolNumber, nrhs: UInt)] = [
        (lhs: 11, nrhs: 1),
        (lhs: 12, nrhs: 3),
        (lhs: 12, nrhs: 3),
        (lhs: 12, nrhs: 1),
        (lhs: 13, nrhs: 3),
        (lhs: 13, nrhs: 3),
        (lhs: 13, nrhs: 1),
        (lhs: 14, nrhs: 1),
        (lhs: 14, nrhs: 3),
        (lhs: 15, nrhs: 5),
        (lhs: 15, nrhs: 4),
        (lhs: 15, nrhs: 2),
        (lhs: 15, nrhs: 3),
        (lhs: 15, nrhs: 1),
        (lhs: 15, nrhs: 2),
        (lhs: 15, nrhs: 1),
        (lhs: 16, nrhs: 1),
        (lhs: 17, nrhs: 1),
    ]

    // Stack

    var yyStack: [(stateOrRule: CitronStateOrRule , symbolCode: CitronSymbolNumber, symbol: CitronSymbol)]  = [
        (stateOrRule: .state(0), symbolCode: 0, symbol: .yyBaseOfStack)
    ]
    var maxStackSize: Int? = nil
    var maxAttainedStackSize: Int = 0

    // Tracing

    var isTracingEnabled: Bool = false
    var isTracingPrintsSymbolValues: Bool = false
    var isTracingPrintsTokenValues: Bool = false
    let yySymbolName: [String] = [
    /*  0 */ "$",
    /*  1 */ "Add",
    /*  2 */ "Subtract",
    /*  3 */ "Multiply",
    /*  4 */ "Divide",
    /*  5 */ "LeftParen",
    /*  6 */ "RightParen",
    /*  7 */ "Feet",
    /*  8 */ "Inches",
    /*  9 */ "Integer",
    /* 10 */ "Fraction",
    /* 11 */ "equation",
    /* 12 */ "expression",
    /* 13 */ "multiplicative",
    /* 14 */ "atom",
    /* 15 */ "quantity",
    /* 16 */ "integer",
    /* 17 */ "fraction",
    ]
    let yyRuleText: [String] = [
        /*   0 */ "equation ::= expression(e)",
        /*   1 */ "expression ::= multiplicative(left) Add expression(right)",
        /*   2 */ "expression ::= multiplicative(left) Subtract expression(right)",
        /*   3 */ "expression ::= multiplicative(x)",
        /*   4 */ "multiplicative ::= atom(left) Multiply atom(right)",
        /*   5 */ "multiplicative ::= atom(left) Divide atom(right)",
        /*   6 */ "multiplicative ::= atom(x)",
        /*   7 */ "atom ::= quantity(x)",
        /*   8 */ "atom ::= LeftParen expression(x) RightParen",
        /*   9 */ "quantity ::= integer(f) Feet integer(i_int) fraction(i_frac) Inches",
        /*  10 */ "quantity ::= integer(f) Feet fraction(i_frac) Inches",
        /*  11 */ "quantity ::= integer(f) Feet",
        /*  12 */ "quantity ::= integer(i_int) fraction(i_frac) Inches",
        /*  13 */ "quantity ::= integer(i_int)",
        /*  14 */ "quantity ::= fraction(i_frac) Inches",
        /*  15 */ "quantity ::= fraction(i_frac)",
        /*  16 */ "integer ::= Integer(x)",
        /*  17 */ "fraction ::= Fraction(x)",
    ]

    // Function definitions

    func yyTokenToSymbol(_ token: CitronToken) -> CitronSymbol {
        return .yy0(token)
    }

    func yyInvokeCodeBlockForRule(ruleNumber: CitronRuleNumber) throws -> CitronSymbol {
        switch (ruleNumber) {
        case 0: /* equation ::= expression(e) */
            func codeBlockForRule00(e: Evaluatable) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 6)

    return e

#sourceLocation()
}
            if case .yy19(let e) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule00(e: e))
            }
        case 1: /* expression ::= multiplicative(left) Add expression(right) */
            func codeBlockForRule01(left: Evaluatable, right: Evaluatable) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 10)

    return .add(left, right)

#sourceLocation()
}
            if case .yy19(let left) = yySymbolOnStack(distanceFromTop: 2),
               case .yy19(let right) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule01(left: left, right: right))
            }
        case 2: /* expression ::= multiplicative(left) Subtract expression(right) */
            func codeBlockForRule02(left: Evaluatable, right: Evaluatable) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 13)

    return .subtract(left, right)

#sourceLocation()
}
            if case .yy19(let left) = yySymbolOnStack(distanceFromTop: 2),
               case .yy19(let right) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule02(left: left, right: right))
            }
        case 3: /* expression ::= multiplicative(x) */
            func codeBlockForRule03(x: Evaluatable) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 16)

    return x

#sourceLocation()
}
            if case .yy19(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule03(x: x))
            }
        case 4: /* multiplicative ::= atom(left) Multiply atom(right) */
            func codeBlockForRule04(left: Evaluatable, right: Evaluatable) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 20)

    return .multiply(left, right)

#sourceLocation()
}
            if case .yy19(let left) = yySymbolOnStack(distanceFromTop: 2),
               case .yy19(let right) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule04(left: left, right: right))
            }
        case 5: /* multiplicative ::= atom(left) Divide atom(right) */
            func codeBlockForRule05(left: Evaluatable, right: Evaluatable) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 23)

    return .divide(left, right)

#sourceLocation()
}
            if case .yy19(let left) = yySymbolOnStack(distanceFromTop: 2),
               case .yy19(let right) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule05(left: left, right: right))
            }
        case 6: /* multiplicative ::= atom(x) */
            func codeBlockForRule06(x: Evaluatable) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 26)

    return x

#sourceLocation()
}
            if case .yy19(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule06(x: x))
            }
        case 7: /* atom ::= quantity(x) */
            func codeBlockForRule07(x: Evaluatable) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 30)

    return x

#sourceLocation()
}
            if case .yy19(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule07(x: x))
            }
        case 8: /* atom ::= LeftParen expression(x) RightParen */
            func codeBlockForRule08(x: Evaluatable) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 33)

    return x

#sourceLocation()
}
            if case .yy19(let x) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy19(try codeBlockForRule08(x: x))
            }
        case 9: /* quantity ::= integer(f) Feet integer(i_int) fraction(i_frac) Inches */
            func codeBlockForRule09(f: Int, i_int: Int, i_frac: Fraction) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 37)

    return .quantity((f * 12 + i_int) * i_frac.1 + i_frac.0, i_frac.1)

#sourceLocation()
}
            if case .yy8(let f) = yySymbolOnStack(distanceFromTop: 4),
               case .yy8(let i_int) = yySymbolOnStack(distanceFromTop: 2),
               case .yy27(let i_frac) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy19(try codeBlockForRule09(f: f, i_int: i_int, i_frac: i_frac))
            }
        case 10: /* quantity ::= integer(f) Feet fraction(i_frac) Inches */
            func codeBlockForRule10(f: Int, i_frac: Fraction) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 40)

    return .quantity(f * 12 * i_frac.1 + i_frac.0, i_frac.1)

#sourceLocation()
}
            if case .yy8(let f) = yySymbolOnStack(distanceFromTop: 3),
               case .yy27(let i_frac) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy19(try codeBlockForRule10(f: f, i_frac: i_frac))
            }
        case 11: /* quantity ::= integer(f) Feet */
            func codeBlockForRule11(f: Int) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 43)

    return .quantity(f * 12, 1)

#sourceLocation()
}
            if case .yy8(let f) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy19(try codeBlockForRule11(f: f))
            }
        case 12: /* quantity ::= integer(i_int) fraction(i_frac) Inches */
            func codeBlockForRule12(i_int: Int, i_frac: Fraction) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 46)

    return .quantity(i_int * i_frac.1 + i_frac.0, i_frac.1)

#sourceLocation()
}
            if case .yy8(let i_int) = yySymbolOnStack(distanceFromTop: 2),
               case .yy27(let i_frac) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy19(try codeBlockForRule12(i_int: i_int, i_frac: i_frac))
            }
        case 13: /* quantity ::= integer(i_int) */
            func codeBlockForRule13(i_int: Int) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 49)

    return .quantity(i_int, 1)

#sourceLocation()
}
            if case .yy8(let i_int) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule13(i_int: i_int))
            }
        case 14: /* quantity ::= fraction(i_frac) Inches */
            func codeBlockForRule14(i_frac: Fraction) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 52)

    return .quantity(i_frac.0, i_frac.1)

#sourceLocation()
}
            if case .yy27(let i_frac) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy19(try codeBlockForRule14(i_frac: i_frac))
            }
        case 15: /* quantity ::= fraction(i_frac) */
            func codeBlockForRule15(i_frac: Fraction) throws -> Evaluatable {
#sourceLocation(file: "../grammar.y", line: 55)

    return .quantity(i_frac.0, i_frac.1)

#sourceLocation()
}
            if case .yy27(let i_frac) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy19(try codeBlockForRule15(i_frac: i_frac))
            }
        case 16: /* integer ::= Integer(x) */
            func codeBlockForRule16(x: Token) throws -> Int {
#sourceLocation(file: "../grammar.y", line: 60)

    switch(x) {
    case .integer(let int):
        return int
    default:
        return 0
    }

#sourceLocation()
}
            if case .yy0(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy8(try codeBlockForRule16(x: x))
            }
        case 17: /* fraction ::= Fraction(x) */
            func codeBlockForRule17(x: Token) throws -> Fraction {
#sourceLocation(file: "../grammar.y", line: 70)

    switch(x) {
    case .fraction(let n, let d):
        return (n, d)
    default:
        return (0, 1)
    }

#sourceLocation()
}
            if case .yy0(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy27(try codeBlockForRule17(x: x))
            }
        default:
            fatalError("Can't invoke code block for rule number \(ruleNumber) - no such rule")
        }
        fatalError("Can't resolve types correctly for invoking code block for rule number \(ruleNumber)")
    }

    private func yySymbolOnStack(distanceFromTop: Int) -> CitronSymbol {
        assert(yyStack.count > distanceFromTop)
        return yyStack[yyStack.count - 1 - distanceFromTop].symbol
    }

    func yyUnwrapResultFromSymbol(_ symbol: CitronSymbol) -> CitronResult {
        if case .yy19(let result) = symbol {
            return result
        } else {
            fatalError("Unexpected mismatch in result type")
        }
    }

    // Error capturing

    typealias CitronErrorCaptureDelegate = _WoodworkingCalculatorParserCitronErrorCaptureDelegate

    weak var errorCaptureDelegate: CitronErrorCaptureDelegate? = nil

    let yyErrorCaptureSymbolNumbersForState: [CitronStateNumber:[CitronSymbolNumber]] = [:]
    let yyCanErrorCapture: Bool = false
    let yyErrorCaptureDirectives: [CitronSymbolNumber:(endAfter:[[CitronTokenCode]],endBefore:[CitronTokenCode])] = [:]
    let yyErrorCaptureEndBeforeTokens: Set<CitronSymbolNumber> = []

    let yyErrorCaptureEndAfterSequenceEndingTokens: Set<CitronSymbolNumber> = []

    func yyShouldSaveErrorForCapturing(error: Error) -> Bool {
        fatalError("This parser was not generated with error capturing information")
    }

    func yyCaptureError(on symbolCode: CitronNonTerminalCode, error: Error, state: CitronErrorCaptureState) -> CitronSymbol? {
        fatalError("This parser was not generated with error capturing information")
    }

    func yySymbolContent(_ symbol: CitronSymbol) -> Any { return symbol.typeErasedContent() }

    let yyStartSymbolNumber: CitronSymbolNumber = 11
    let yyEndStateNumber: CitronStateNumber = 16

    var yyErrorCaptureSavedError: (error: Error, isLexerError: Bool)? = nil
    var yyErrorCaptureTokensSinceError: [(token: CitronToken, tokenCode: CitronTokenCode)] = []
    var yyErrorCaptureStackIndices: [Int] = []
    var yyErrorCaptureStartSymbolStackIndex: Int? = nil

    var numberOfCapturedErrors: Int = 0
}

protocol _WoodworkingCalculatorParserCitronErrorCaptureDelegate : AnyObject {
    func shouldSaveErrorForCapturing(error: Error) -> Bool
}

extension _WoodworkingCalculatorParserCitronErrorCaptureDelegate {
    func shouldSaveErrorForCapturing(error: Error) -> Bool {
        return true
    }
}

// Ability to use == to compare CitronSymbolCode with CitronTokenCode / CitronNonTerminalCode

extension WoodworkingCalculatorParser.CitronSymbolCode {
    static func == (a: WoodworkingCalculatorParser.CitronSymbolCode, b: WoodworkingCalculatorParser.CitronTokenCode) -> Bool {
        guard case let .token(code) = a else { return false }
        return (code == b)
    }
    static func == (a: WoodworkingCalculatorParser.CitronTokenCode, b: WoodworkingCalculatorParser.CitronSymbolCode) -> Bool {
        guard case let .token(code) = b else { return false }
        return (code == a)
    }
    static func == (a: WoodworkingCalculatorParser.CitronSymbolCode, b: WoodworkingCalculatorParser.CitronNonTerminalCode) -> Bool {
        guard case let .nonterminal(code) = a else { return false }
        return (code == b)
    }
    static func == (a: WoodworkingCalculatorParser.CitronNonTerminalCode, b: WoodworkingCalculatorParser.CitronSymbolCode) -> Bool {
        guard case let .nonterminal(code) = b else { return false }
        return (code == a)
    }
}

// Ability to use switch (symbolCode) { case .tokenCode: ...; case .nonterminalCode: ... }

extension WoodworkingCalculatorParser.CitronSymbolCode {
    static func ~= (pattern: WoodworkingCalculatorParser.CitronTokenCode, value: WoodworkingCalculatorParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
    static func ~= (pattern: WoodworkingCalculatorParser.CitronNonTerminalCode, value: WoodworkingCalculatorParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
}
