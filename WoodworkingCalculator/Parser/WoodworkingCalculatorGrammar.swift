// This file is automatically generated by Citron version 2.0.
//
// The parser class defined below conforms to the CitronParser protocol
// defined in CitronParser.swift. 
// 
// The authors of Citron disclaim copyright to the source code in this file.

// Preface

#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 1)

    func forceUnwrapDimension(_ token: WoodworkingCalculatorToken) -> Dimension {
        if case .dimension(let dim) = token {
            return dim
        } else {
            preconditionFailure("lexer did not return Dimension when expected")
        }
    }

#sourceLocation()

// Parser class

class WoodworkingCalculatorGrammar: CitronParser {

    // Types

    typealias CitronSymbolNumber = UInt8
    typealias CitronStateNumber = UInt8
    typealias CitronRuleNumber = UInt8

    enum CitronTokenCode: CitronSymbolNumber {
      case Add                            =   1
      case Subtract                       =   2
      case Multiply                       =   3
      case Divide                         =   4
      case LeftParen                      =   5
      case RightParen                     =   6
      case Meters                         =   7
      case Centimeters                    =   8
      case Millimeters                    =   9
      case Feet                           =  10
      case Inches                         =  11
      case Integer                        =  12
      case MixedNumber                    =  13
      case Real                           =  14
      case Dimension                      =  15
    }

    enum CitronNonTerminalCode: CitronSymbolNumber {
      case equation                       =  16
      case expression                     =  17
      case multiplicative                 =  18
      case atom                           =  19
      case quantity                       =  20
      case integer                        =  21
      case dimension                      =  22
      case real                           =  23
      case mixed_number                   =  24
    }

    enum CitronSymbolCode : RawRepresentable, Equatable {
        case token(CitronTokenCode)
        case nonterminal(CitronNonTerminalCode)
        case endOfInput

        init(_ token: CitronTokenCode) { self = .token(token) }
        init(_ nonterminal: CitronNonTerminalCode) { self = .nonterminal(nonterminal) }
        init(rawValue: CitronSymbolNumber) {
            if (rawValue == 0) {
                self = .endOfInput
            } else if (rawValue < 16) {
                self = .token(CitronTokenCode(rawValue: rawValue)!)
            } else if (rawValue < 25) {
                self = .nonterminal(CitronNonTerminalCode(rawValue: rawValue)!)
            } else {
                fatalError()
            }
        }

        typealias RawValue = CitronSymbolNumber
        var rawValue: CitronSymbolNumber {
            switch (self) {
            case .token(let t): return t.rawValue
            case .nonterminal(let nt): return nt.rawValue
            case .endOfInput: return 0
            }
        }
    }

    typealias CitronToken = WoodworkingCalculatorToken

    enum CitronSymbol {
        case yyBaseOfStack
        case yy0(CitronToken)
        case yy4(Int)
        case yy5(Dimension)
        case yy8(Double)
        case yy11(UncheckedRational)
        case yy32(EvaluatableCalculation)

        func typeErasedContent() -> Any {
            switch (self) {
            case .yyBaseOfStack: fatalError()
            case .yy0(let value): return value as Any
            case .yy4(let value): return value as Any
            case .yy5(let value): return value as Any
            case .yy8(let value): return value as Any
            case .yy11(let value): return value as Any
            case .yy32(let value): return value as Any
            }
        }
    }

    typealias CitronResult = EvaluatableCalculation

    // Counts

    let yyNumberOfSymbols: Int = 25
    let yyNumberOfStates: Int = 31

    // Action tables

    let yyLookaheadAction: [(CitronSymbolNumber, CitronParsingAction)] = [
/*   0 */  (16, .ACCEPT),   (17, .SH(23)), (18, .SH(24)), (19, .RD( 6)), (20, .RD( 7)),
/*   5 */  (21, .SH(20)), (15, .SR(45)), (23, .SH(19)), (24, .SH(27)), (17, .SH(21)),
/*  10 */  (18, .SH(24)), (19, .RD( 6)), (20, .RD( 7)), (21, .SH(20)), (25, .RD( 2)),
/*  15 */  (23, .SH(19)), (24, .SH(27)), (17, .SH(22)), (18, .SH(24)), (19, .RD( 6)),
/*  20 */  (20, .RD( 7)), (21, .SH(20)), (25, .RD( 2)), (23, .SH(19)), (24, .SH(27)),
/*  25 */  (22, .RD(33)), (18, .SH(25)), (19, .RD( 6)), (20, .RD( 7)), (21, .SH(20)),
/*  30 */  (11, .SH( 9)), (23, .SH(19)), (24, .SH(27)), (22, .RD(39)), (18, .SH(26)),
/*  35 */  (19, .RD( 6)), (20, .RD( 7)), (21, .SH(20)), ( 2, .SH( 8)), (23, .SH(19)),
/*  40 */  (24, .SH(27)), ( 5, .SH( 1)), ( 7, .SH(14)), ( 8, .SH(13)), ( 9, .SH(12)),
/*  45 */  (10, .SH(11)), (11, .SH(10)), (22, .RD(31)), (12, .SR(42)), (13, .SR(43)),
/*  50 */  (14, .SR(44)), (19, .RD( 5)), (20, .RD( 7)), (21, .SH(20)), (11, .SR(25)),
/*  55 */  (23, .SH(19)), (24, .SH(27)), (19, .RD( 4)), (20, .RD( 7)), (21, .SH(20)),
/*  60 */  (11, .SR(24)), (23, .SH(19)), (24, .SH(27)), ( 7, .SH(18)), ( 8, .SH(17)),
/*  65 */  ( 9, .SH(16)), (10, .SH( 7)), (11, .SH(15)), (22, .RD(21)), (12, .SR(42)),
/*  70 */  (13, .SR(43)), (14, .SR(44)), (15, .SR(45)), (21, .SH(29)), (22, .RD(29)),
/*  75 */  (23, .SH(28)), (24, .SH(30)), ( 5, .SH( 2)), (20, .RD( 8)), (21, .SH(20)),
/*  80 */  (25, .RD( 2)), (23, .SH(19)), (24, .SH(27)), (25, .RD( 2)), (12, .SR(42)),
/*  85 */  (13, .SR(43)), (14, .SR(44)), ( 1, .SH( 4)), ( 2, .SH( 3)), ( 1, .SH( 4)),
/*  90 */  ( 2, .SH( 3)), (22, .RD(17)), ( 6, .SR( 9)), (22, .RD(13)), ( 6, .SR(10)),
/*  95 */  ( 0, .RD( 0)), ( 1, .SH( 4)), ( 2, .SH( 3)), (22, .RD(36)), ( 3, .SH( 6)),
/* 100 */  ( 4, .SH( 5)), (22, .RD(19)), (22, .RD(15)), (11, .SR(23)), (22, .RD(11)),
    ]

    let yyShiftUseDefault: Int = 105
    let yyShiftOffsetMin: Int = -9
    let yyShiftOffsetMax: Int = 96
    let yyShiftOffset: [Int] = [
        /*     0 */    36,   36,   36,   36,   36,   36,   36,   57,   72,   -9,
        /*    10 */    -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   35,
        /*    20 */    56,   86,   88,   95,   96,   96,   96,   19,   43,   49,
        /*    30 */    92,
    ]

    let yyReduceUseDefault: Int = -17
    let yyReduceOffsetMin: Int =   -16
    let yyReduceOffsetMax: Int =   82
    let yyReduceOffset: [Int] = [
        /*     0 */   -16,   -8,    0,    8,   16,   32,   38,   52,   58,    3,
        /*    10 */    11,   25,   46,   69,   71,   76,   79,   80,   82,
    ]

    let yyDefaultAction: [CitronParsingAction] = [
  /*     0 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*     5 */  .ERROR , .ERROR , .RD(30), .ERROR , .RD(34),
  /*    10 */  .RD(40), .RD(32), .RD(22), .RD(18), .RD(14),
  /*    15 */  .RD(37), .RD(20), .RD(16), .RD(12), .RD(41),
  /*    20 */  .RD(38), .ERROR , .ERROR , .ERROR , .RD( 3),
  /*    25 */  .RD( 2), .RD( 1), .RD(35), .RD(28), .RD(27),
  /*    30 */  .RD(26),
    ]

    // Fallback

    let yyHasFallback: Bool = false
    let yyFallback: [CitronSymbolNumber] = []

    // Wildcard

    let yyWildcard: CitronSymbolNumber? = nil

    // Rules

    let yyRuleInfo: [(lhs: CitronSymbolNumber, nrhs: UInt)] = [
        (lhs: 16, nrhs: 1),
        (lhs: 17, nrhs: 3),
        (lhs: 17, nrhs: 3),
        (lhs: 17, nrhs: 1),
        (lhs: 18, nrhs: 3),
        (lhs: 18, nrhs: 3),
        (lhs: 18, nrhs: 1),
        (lhs: 19, nrhs: 1),
        (lhs: 19, nrhs: 2),
        (lhs: 19, nrhs: 3),
        (lhs: 19, nrhs: 4),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 2),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 2),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 2),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 2),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 2),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 2),
        (lhs: 20, nrhs: 4),
        (lhs: 20, nrhs: 4),
        (lhs: 20, nrhs: 4),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 2),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 2),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 2),
        (lhs: 20, nrhs: 1),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 2),
        (lhs: 20, nrhs: 1),
        (lhs: 20, nrhs: 3),
        (lhs: 20, nrhs: 2),
        (lhs: 20, nrhs: 1),
        (lhs: 21, nrhs: 1),
        (lhs: 24, nrhs: 1),
        (lhs: 23, nrhs: 1),
        (lhs: 22, nrhs: 1),
    ]

    // Stack

    var yyStack: [(stateOrRule: CitronStateOrRule , symbolCode: CitronSymbolNumber, symbol: CitronSymbol)]  = [
        (stateOrRule: .state(0), symbolCode: 0, symbol: .yyBaseOfStack)
    ]
    var maxStackSize: Int? = nil
    var maxAttainedStackSize: Int = 0

    // Tracing

    var isTracingEnabled: Bool = false
    var isTracingPrintsSymbolValues: Bool = false
    var isTracingPrintsTokenValues: Bool = false
    let yySymbolName: [String] = [
    /*  0 */ "$",
    /*  1 */ "Add",
    /*  2 */ "Subtract",
    /*  3 */ "Multiply",
    /*  4 */ "Divide",
    /*  5 */ "LeftParen",
    /*  6 */ "RightParen",
    /*  7 */ "Meters",
    /*  8 */ "Centimeters",
    /*  9 */ "Millimeters",
    /* 10 */ "Feet",
    /* 11 */ "Inches",
    /* 12 */ "Integer",
    /* 13 */ "MixedNumber",
    /* 14 */ "Real",
    /* 15 */ "Dimension",
    /* 16 */ "equation",
    /* 17 */ "expression",
    /* 18 */ "multiplicative",
    /* 19 */ "atom",
    /* 20 */ "quantity",
    /* 21 */ "integer",
    /* 22 */ "dimension",
    /* 23 */ "real",
    /* 24 */ "mixed_number",
    ]
    let yyRuleText: [String] = [
        /*   0 */ "equation ::= expression(e)",
        /*   1 */ "expression ::= expression(left) Add multiplicative(right)",
        /*   2 */ "expression ::= expression(left) Subtract multiplicative(right)",
        /*   3 */ "expression ::= multiplicative(x)",
        /*   4 */ "multiplicative ::= multiplicative(left) Multiply atom(right)",
        /*   5 */ "multiplicative ::= multiplicative(left) Divide atom(right)",
        /*   6 */ "multiplicative ::= atom(x)",
        /*   7 */ "atom ::= quantity(x)",
        /*   8 */ "atom ::= Subtract quantity(x)",
        /*   9 */ "atom ::= LeftParen expression(x) RightParen",
        /*  10 */ "atom ::= Subtract LeftParen expression(x) RightParen",
        /*  11 */ "quantity ::= integer(q) Meters dimension(d)",
        /*  12 */ "quantity ::= integer(q) Meters",
        /*  13 */ "quantity ::= real(q) Meters dimension(d)",
        /*  14 */ "quantity ::= real(q) Meters",
        /*  15 */ "quantity ::= integer(q) Centimeters dimension(d)",
        /*  16 */ "quantity ::= integer(q) Centimeters",
        /*  17 */ "quantity ::= real(q) Centimeters dimension(d)",
        /*  18 */ "quantity ::= real(q) Centimeters",
        /*  19 */ "quantity ::= integer(q) Millimeters dimension(d)",
        /*  20 */ "quantity ::= integer(q) Millimeters",
        /*  21 */ "quantity ::= real(q) Millimeters dimension(d)",
        /*  22 */ "quantity ::= real(q) Millimeters",
        /*  23 */ "quantity ::= integer(f) Feet mixed_number(i) Inches",
        /*  24 */ "quantity ::= integer(f) Feet integer(i) Inches",
        /*  25 */ "quantity ::= integer(f) Feet real(i) Inches",
        /*  26 */ "quantity ::= integer(f) Feet mixed_number(i)",
        /*  27 */ "quantity ::= integer(f) Feet integer(i)",
        /*  28 */ "quantity ::= integer(f) Feet real(i)",
        /*  29 */ "quantity ::= integer(f) Feet dimension(d)",
        /*  30 */ "quantity ::= integer(f) Feet",
        /*  31 */ "quantity ::= real(f) Feet dimension(d)",
        /*  32 */ "quantity ::= real(f) Feet",
        /*  33 */ "quantity ::= mixed_number(i) Inches dimension(d)",
        /*  34 */ "quantity ::= mixed_number(i) Inches",
        /*  35 */ "quantity ::= mixed_number(i)",
        /*  36 */ "quantity ::= integer(i) Inches dimension(d)",
        /*  37 */ "quantity ::= integer(i) Inches",
        /*  38 */ "quantity ::= integer(i)",
        /*  39 */ "quantity ::= real(i) Inches dimension(d)",
        /*  40 */ "quantity ::= real(i) Inches",
        /*  41 */ "quantity ::= real(i)",
        /*  42 */ "integer ::= Integer(x)",
        /*  43 */ "mixed_number ::= MixedNumber(x)",
        /*  44 */ "real ::= Real(x)",
        /*  45 */ "dimension ::= Dimension(x)",
    ]

    // Function definitions

    func yyTokenToSymbol(_ token: CitronToken) -> CitronSymbol {
        return .yy0(token)
    }

    func yyInvokeCodeBlockForRule(ruleNumber: CitronRuleNumber) throws -> CitronSymbol {
        switch (ruleNumber) {
        case 0: /* equation ::= expression(e) */
            func codeBlockForRule00(e: EvaluatableCalculation) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 16)
 e 
#sourceLocation()
}
            if case .yy32(let e) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule00(e: e))
            }
        case 1: /* expression ::= expression(left) Add multiplicative(right) */
            func codeBlockForRule01(left: EvaluatableCalculation, right: EvaluatableCalculation) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 19)
 .add(left, right) 
#sourceLocation()
}
            if case .yy32(let left) = yySymbolOnStack(distanceFromTop: 2),
               case .yy32(let right) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule01(left: left, right: right))
            }
        case 2: /* expression ::= expression(left) Subtract multiplicative(right) */
            func codeBlockForRule02(left: EvaluatableCalculation, right: EvaluatableCalculation) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 20)
 .subtract(left, right) 
#sourceLocation()
}
            if case .yy32(let left) = yySymbolOnStack(distanceFromTop: 2),
               case .yy32(let right) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule02(left: left, right: right))
            }
        case 3: /* expression ::= multiplicative(x) */
            func codeBlockForRule03(x: EvaluatableCalculation) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 21)
 x 
#sourceLocation()
}
            if case .yy32(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule03(x: x))
            }
        case 4: /* multiplicative ::= multiplicative(left) Multiply atom(right) */
            func codeBlockForRule04(left: EvaluatableCalculation, right: EvaluatableCalculation) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 24)
 .multiply(left, right) 
#sourceLocation()
}
            if case .yy32(let left) = yySymbolOnStack(distanceFromTop: 2),
               case .yy32(let right) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule04(left: left, right: right))
            }
        case 5: /* multiplicative ::= multiplicative(left) Divide atom(right) */
            func codeBlockForRule05(left: EvaluatableCalculation, right: EvaluatableCalculation) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 25)
 .divide(left, right) 
#sourceLocation()
}
            if case .yy32(let left) = yySymbolOnStack(distanceFromTop: 2),
               case .yy32(let right) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule05(left: left, right: right))
            }
        case 6: /* multiplicative ::= atom(x) */
            func codeBlockForRule06(x: EvaluatableCalculation) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 26)
 x 
#sourceLocation()
}
            if case .yy32(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule06(x: x))
            }
        case 7: /* atom ::= quantity(x) */
            func codeBlockForRule07(x: EvaluatableCalculation) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 33)
 x 
#sourceLocation()
}
            if case .yy32(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule07(x: x))
            }
        case 8: /* atom ::= Subtract quantity(x) */
            func codeBlockForRule08(x: EvaluatableCalculation) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 34)
 .subtract(.rational(UncheckedRational(0, 1), .unitless), x) 
#sourceLocation()
}
            if case .yy32(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule08(x: x))
            }
        case 9: /* atom ::= LeftParen expression(x) RightParen */
            func codeBlockForRule09(x: EvaluatableCalculation) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 35)
 x 
#sourceLocation()
}
            if case .yy32(let x) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule09(x: x))
            }
        case 10: /* atom ::= Subtract LeftParen expression(x) RightParen */
            func codeBlockForRule10(x: EvaluatableCalculation) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 36)
 .subtract(.rational(UncheckedRational(0, 1), .unitless), x) 
#sourceLocation()
}
            if case .yy32(let x) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule10(x: x))
            }
        case 11: /* quantity ::= integer(q) Meters dimension(d) */
            func codeBlockForRule11(q: Int, d: Dimension) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 41)
 .real(Double(q) / 0.0254, d) 
#sourceLocation()
}
            if case .yy4(let q) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule11(q: q, d: d))
            }
        case 12: /* quantity ::= integer(q) Meters */
            func codeBlockForRule12(q: Int) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 42)
 .real(Double(q) / 0.0254, .length) 
#sourceLocation()
}
            if case .yy4(let q) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule12(q: q))
            }
        case 13: /* quantity ::= real(q) Meters dimension(d) */
            func codeBlockForRule13(q: Double, d: Dimension) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 43)
 .real(q / 0.0254, d) 
#sourceLocation()
}
            if case .yy8(let q) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule13(q: q, d: d))
            }
        case 14: /* quantity ::= real(q) Meters */
            func codeBlockForRule14(q: Double) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 44)
 .real(q / 0.0254, .length) 
#sourceLocation()
}
            if case .yy8(let q) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule14(q: q))
            }
        case 15: /* quantity ::= integer(q) Centimeters dimension(d) */
            func codeBlockForRule15(q: Int, d: Dimension) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 46)
 .real(Double(q) / 2.54, d) 
#sourceLocation()
}
            if case .yy4(let q) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule15(q: q, d: d))
            }
        case 16: /* quantity ::= integer(q) Centimeters */
            func codeBlockForRule16(q: Int) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 47)
 .real(Double(q) / 2.54, .length) 
#sourceLocation()
}
            if case .yy4(let q) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule16(q: q))
            }
        case 17: /* quantity ::= real(q) Centimeters dimension(d) */
            func codeBlockForRule17(q: Double, d: Dimension) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 48)
 .real(q / 2.54, d) 
#sourceLocation()
}
            if case .yy8(let q) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule17(q: q, d: d))
            }
        case 18: /* quantity ::= real(q) Centimeters */
            func codeBlockForRule18(q: Double) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 49)
 .real(q / 2.54, .length) 
#sourceLocation()
}
            if case .yy8(let q) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule18(q: q))
            }
        case 19: /* quantity ::= integer(q) Millimeters dimension(d) */
            func codeBlockForRule19(q: Int, d: Dimension) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 51)
 .real(Double(q) / 25.4, d) 
#sourceLocation()
}
            if case .yy4(let q) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule19(q: q, d: d))
            }
        case 20: /* quantity ::= integer(q) Millimeters */
            func codeBlockForRule20(q: Int) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 52)
 .real(Double(q) / 25.4, .length) 
#sourceLocation()
}
            if case .yy4(let q) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule20(q: q))
            }
        case 21: /* quantity ::= real(q) Millimeters dimension(d) */
            func codeBlockForRule21(q: Double, d: Dimension) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 53)
 .real(q / 25.4, d) 
#sourceLocation()
}
            if case .yy8(let q) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule21(q: q, d: d))
            }
        case 22: /* quantity ::= real(q) Millimeters */
            func codeBlockForRule22(q: Double) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 54)
 .real(q / 25.4, .length) 
#sourceLocation()
}
            if case .yy8(let q) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule22(q: q))
            }
        case 23: /* quantity ::= integer(f) Feet mixed_number(i) Inches */
            func codeBlockForRule23(f: Int, i: UncheckedRational) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 56)
 .rational(UncheckedRational((f * 12) * i.den + i.num, i.den), .length) 
#sourceLocation()
}
            if case .yy4(let f) = yySymbolOnStack(distanceFromTop: 3),
               case .yy11(let i) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule23(f: f, i: i))
            }
        case 24: /* quantity ::= integer(f) Feet integer(i) Inches */
            func codeBlockForRule24(f: Int, i: Int) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 57)
 .rational(UncheckedRational(f * 12 + i, 1), .length) 
#sourceLocation()
}
            if case .yy4(let f) = yySymbolOnStack(distanceFromTop: 3),
               case .yy4(let i) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule24(f: f, i: i))
            }
        case 25: /* quantity ::= integer(f) Feet real(i) Inches */
            func codeBlockForRule25(f: Int, i: Double) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 58)
 .real(Double(f * 12) + i, .length) 
#sourceLocation()
}
            if case .yy4(let f) = yySymbolOnStack(distanceFromTop: 3),
               case .yy8(let i) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule25(f: f, i: i))
            }
        case 26: /* quantity ::= integer(f) Feet mixed_number(i) */
            func codeBlockForRule26(f: Int, i: UncheckedRational) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 59)
 .rational(UncheckedRational((f * 12) * i.den + i.num, i.den), .length) 
#sourceLocation()
}
            if case .yy4(let f) = yySymbolOnStack(distanceFromTop: 2),
               case .yy11(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule26(f: f, i: i))
            }
        case 27: /* quantity ::= integer(f) Feet integer(i) */
            func codeBlockForRule27(f: Int, i: Int) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 60)
 .rational(UncheckedRational(f * 12 + i, 1), .length) 
#sourceLocation()
}
            if case .yy4(let f) = yySymbolOnStack(distanceFromTop: 2),
               case .yy4(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule27(f: f, i: i))
            }
        case 28: /* quantity ::= integer(f) Feet real(i) */
            func codeBlockForRule28(f: Int, i: Double) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 61)
 .real(Double(f * 12) + i, .length) 
#sourceLocation()
}
            if case .yy4(let f) = yySymbolOnStack(distanceFromTop: 2),
               case .yy8(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule28(f: f, i: i))
            }
        case 29: /* quantity ::= integer(f) Feet dimension(d) */
            func codeBlockForRule29(f: Int, d: Dimension) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 63)
 .rational(UncheckedRational(f * 12, 1), d) 
#sourceLocation()
}
            if case .yy4(let f) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule29(f: f, d: d))
            }
        case 30: /* quantity ::= integer(f) Feet */
            func codeBlockForRule30(f: Int) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 64)
 .rational(UncheckedRational(f * 12, 1), .length) 
#sourceLocation()
}
            if case .yy4(let f) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule30(f: f))
            }
        case 31: /* quantity ::= real(f) Feet dimension(d) */
            func codeBlockForRule31(f: Double, d: Dimension) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 65)
 .real(f * 12, d) 
#sourceLocation()
}
            if case .yy8(let f) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule31(f: f, d: d))
            }
        case 32: /* quantity ::= real(f) Feet */
            func codeBlockForRule32(f: Double) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 66)
 .real(f * 12, .length) 
#sourceLocation()
}
            if case .yy8(let f) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule32(f: f))
            }
        case 33: /* quantity ::= mixed_number(i) Inches dimension(d) */
            func codeBlockForRule33(i: UncheckedRational, d: Dimension) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 68)
 .rational(i, d) 
#sourceLocation()
}
            if case .yy11(let i) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule33(i: i, d: d))
            }
        case 34: /* quantity ::= mixed_number(i) Inches */
            func codeBlockForRule34(i: UncheckedRational) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 69)
 .rational(i, .length) 
#sourceLocation()
}
            if case .yy11(let i) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule34(i: i))
            }
        case 35: /* quantity ::= mixed_number(i) */
            func codeBlockForRule35(i: UncheckedRational) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 70)
 .rational(i, .unitless) 
#sourceLocation()
}
            if case .yy11(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule35(i: i))
            }
        case 36: /* quantity ::= integer(i) Inches dimension(d) */
            func codeBlockForRule36(i: Int, d: Dimension) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 71)
 .rational(UncheckedRational(i, 1), d) 
#sourceLocation()
}
            if case .yy4(let i) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule36(i: i, d: d))
            }
        case 37: /* quantity ::= integer(i) Inches */
            func codeBlockForRule37(i: Int) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 72)
 .rational(UncheckedRational(i, 1), .length) 
#sourceLocation()
}
            if case .yy4(let i) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule37(i: i))
            }
        case 38: /* quantity ::= integer(i) */
            func codeBlockForRule38(i: Int) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 73)
 .rational(UncheckedRational(i, 1), .unitless) 
#sourceLocation()
}
            if case .yy4(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule38(i: i))
            }
        case 39: /* quantity ::= real(i) Inches dimension(d) */
            func codeBlockForRule39(i: Double, d: Dimension) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 74)
 .real(i, d) 
#sourceLocation()
}
            if case .yy8(let i) = yySymbolOnStack(distanceFromTop: 2),
               case .yy5(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule39(i: i, d: d))
            }
        case 40: /* quantity ::= real(i) Inches */
            func codeBlockForRule40(i: Double) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 75)
 .real(i, .length) 
#sourceLocation()
}
            if case .yy8(let i) = yySymbolOnStack(distanceFromTop: 1) {
                return .yy32(try codeBlockForRule40(i: i))
            }
        case 41: /* quantity ::= real(i) */
            func codeBlockForRule41(i: Double) throws -> EvaluatableCalculation {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 76)
 .real(i, .unitless) 
#sourceLocation()
}
            if case .yy8(let i) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy32(try codeBlockForRule41(i: i))
            }
        case 42: /* integer ::= Integer(x) */
            func codeBlockForRule42(x: WoodworkingCalculatorToken) throws -> Int {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 79)

    if case .integer(let int) = x {
        return int
    } else {
        preconditionFailure("lexer did not return Token.integer for the Integer token")
    }

#sourceLocation()
}
            if case .yy0(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy4(try codeBlockForRule42(x: x))
            }
        case 43: /* mixed_number ::= MixedNumber(x) */
            func codeBlockForRule43(x: WoodworkingCalculatorToken) throws -> UncheckedRational {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 88)

    if case .rational(let r) = x {
        return r
    } else {
        preconditionFailure("lexer did not return Token.rational for the MixedNumber token")
    }

#sourceLocation()
}
            if case .yy0(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy11(try codeBlockForRule43(x: x))
            }
        case 44: /* real ::= Real(x) */
            func codeBlockForRule44(x: WoodworkingCalculatorToken) throws -> Double {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 97)

    if case .real(let real) = x {
        return real
    } else {
        preconditionFailure("lexer did not return Token.real for the Real token")
    }

#sourceLocation()
}
            if case .yy0(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy8(try codeBlockForRule44(x: x))
            }
        case 45: /* dimension ::= Dimension(x) */
            func codeBlockForRule45(x: WoodworkingCalculatorToken) throws -> Dimension {
#sourceLocation(file: "WoodworkingCalculator/Parser/WoodworkingCalculatorGrammar.y", line: 106)

    if case .dimension(let dimension) = x {
        return dimension
    } else {
        preconditionFailure("lexer did not return Token.dimension for the Dimension token")
    }

#sourceLocation()
}
            if case .yy0(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy5(try codeBlockForRule45(x: x))
            }
        default:
            fatalError("Can't invoke code block for rule number \(ruleNumber) - no such rule")
        }
        fatalError("Can't resolve types correctly for invoking code block for rule number \(ruleNumber)")
    }

    private func yySymbolOnStack(distanceFromTop: Int) -> CitronSymbol {
        assert(yyStack.count > distanceFromTop)
        return yyStack[yyStack.count - 1 - distanceFromTop].symbol
    }

    func yyUnwrapResultFromSymbol(_ symbol: CitronSymbol) -> CitronResult {
        if case .yy32(let result) = symbol {
            return result
        } else {
            fatalError("Unexpected mismatch in result type")
        }
    }

    // Error capturing

    typealias CitronErrorCaptureDelegate = _WoodworkingCalculatorGrammarCitronErrorCaptureDelegate

    weak var errorCaptureDelegate: CitronErrorCaptureDelegate? = nil

    let yyErrorCaptureSymbolNumbersForState: [CitronStateNumber:[CitronSymbolNumber]] = [:]
    let yyCanErrorCapture: Bool = false
    let yyErrorCaptureDirectives: [CitronSymbolNumber:(endAfter:[[CitronTokenCode]],endBefore:[CitronTokenCode])] = [:]
    let yyErrorCaptureEndBeforeTokens: Set<CitronSymbolNumber> = []

    let yyErrorCaptureEndAfterSequenceEndingTokens: Set<CitronSymbolNumber> = []

    func yyShouldSaveErrorForCapturing(error: Error) -> Bool {
        fatalError("This parser was not generated with error capturing information")
    }

    func yyCaptureError(on symbolCode: CitronNonTerminalCode, error: Error, state: CitronErrorCaptureState) -> CitronSymbol? {
        fatalError("This parser was not generated with error capturing information")
    }

    func yySymbolContent(_ symbol: CitronSymbol) -> Any { return symbol.typeErasedContent() }

    let yyStartSymbolNumber: CitronSymbolNumber = 16
    let yyEndStateNumber: CitronStateNumber = 23

    var yyErrorCaptureSavedError: (error: Error, isLexerError: Bool)? = nil
    var yyErrorCaptureTokensSinceError: [(token: CitronToken, tokenCode: CitronTokenCode)] = []
    var yyErrorCaptureStackIndices: [Int] = []
    var yyErrorCaptureStartSymbolStackIndex: Int? = nil

    var numberOfCapturedErrors: Int = 0
}

protocol _WoodworkingCalculatorGrammarCitronErrorCaptureDelegate : AnyObject {
    func shouldSaveErrorForCapturing(error: Error) -> Bool
}

extension _WoodworkingCalculatorGrammarCitronErrorCaptureDelegate {
    func shouldSaveErrorForCapturing(error: Error) -> Bool {
        return true
    }
}

// Ability to use == to compare CitronSymbolCode with CitronTokenCode / CitronNonTerminalCode

extension WoodworkingCalculatorGrammar.CitronSymbolCode {
    static func == (a: WoodworkingCalculatorGrammar.CitronSymbolCode, b: WoodworkingCalculatorGrammar.CitronTokenCode) -> Bool {
        guard case let .token(code) = a else { return false }
        return (code == b)
    }
    static func == (a: WoodworkingCalculatorGrammar.CitronTokenCode, b: WoodworkingCalculatorGrammar.CitronSymbolCode) -> Bool {
        guard case let .token(code) = b else { return false }
        return (code == a)
    }
    static func == (a: WoodworkingCalculatorGrammar.CitronSymbolCode, b: WoodworkingCalculatorGrammar.CitronNonTerminalCode) -> Bool {
        guard case let .nonterminal(code) = a else { return false }
        return (code == b)
    }
    static func == (a: WoodworkingCalculatorGrammar.CitronNonTerminalCode, b: WoodworkingCalculatorGrammar.CitronSymbolCode) -> Bool {
        guard case let .nonterminal(code) = b else { return false }
        return (code == a)
    }
}

// Ability to use switch (symbolCode) { case .tokenCode: ...; case .nonterminalCode: ... }

extension WoodworkingCalculatorGrammar.CitronSymbolCode {
    static func ~= (pattern: WoodworkingCalculatorGrammar.CitronTokenCode, value: WoodworkingCalculatorGrammar.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
    static func ~= (pattern: WoodworkingCalculatorGrammar.CitronNonTerminalCode, value: WoodworkingCalculatorGrammar.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
}
